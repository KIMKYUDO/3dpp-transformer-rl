from __future__ import annotations
from dataclasses import dataclass
from typing import List, Tuple, Optional, Dict
import numpy as np

try:
    # 전처리와 연동이 필요할 때 사용 (테스트에서는 옵션)
    from utils.preprocess import compute_plane_features
except Exception:
    compute_plane_features = None


# Box 타입
Box = Tuple[int, int, int]  # (l, w, h)


@dataclass
class EnvConfig:
    L: int = 100
    W: int = 100
    N: int = 20
    l_range: Tuple[int, int] = (10, 50)
    w_range: Tuple[int, int] = (10, 50)
    h_range: Tuple[int, int] = (10, 50)
    seed: Optional[int] = None
    invalid_penalty: float = -1.0
    # 성공적으로 '배치(place)'한 횟수 제한
    max_steps: Optional[int] = 200
    num_envs: int = 4
    # 무효 시도 허용 상한(연속/누적 관리용)
    max_invalid_attempts: int = 500


class PackingEnv:
    """Heightmap 기반 3D-PP 환경.

    - 상태: heightmap (H=W=컨테이너 평면), 내부적으로 gap/UR 계산 지원
    - step(action): action = (x, y, box_idx, orient_idx)
      * x, y: 좌상단 좌표 (정수 그리드)
      * box_idx: 미배치 박스 인덱스
      * orient_idx: 0..5 (6가지 직교 회전)
    """

    def __init__(self, cfg: EnvConfig):
        self.cfg = cfg
        self.rng = np.random.default_rng(cfg.seed)
        self.L = int(cfg.L)
        self.W = int(cfg.W)
        self.height = np.zeros((self.W, self.L), dtype=np.int32)  # (H, W) = (y, x)
        self.boxes: List[Box] = []
        self.used = np.zeros(0, dtype=bool)
        self.t = 0
        self._sum_vol = 0  # \sum lwh for placed boxes
        self._g_prev = 0   # g_{i-1}
        self.placed_boxes = []   # (x,y,z,l,w,h) 튜플 기록
        self.invalid_penalty = cfg.invalid_penalty

        # 카운터 분리: attempt(시도) / step(성공 배치) / invalid(무효 시도)
        self.invalid_count = 0     # 누적 무효 시도
        self.step_count = 0        # 성공 배치 횟수
        self.max_steps = cfg.max_steps
        

    # ---------- 유틸 ----------
    def _within_bounds(self, x: int, y: int, l: int, w: int) -> bool:
        # 좌상단 (x,y) 기준 박스 (l,w)가 컨테이너 평면 [0,L)×[0,W) 안에 들어오는지
        return (0 <= x) and (0 <= y) and (x + l <= self.L) and (y + w <= self.W)
    
    @staticmethod
    def _orientations(l: int, w: int, h: int) -> List[Box]:
        # 6개의 축정렬 회전(중복 제거, **순서 보존**)
        perms = [(l, w, h), (l, h, w), (w, l, h), (w, h, l), (h, l, w), (h, w, l)]
        uniq: List[Box] = []
        for p in perms:
            if p not in uniq:
                uniq.append(p)
        return uniq

    def _max_height_in_region(self, x0: int, y0: int, l: int, w: int) -> int:
        region = self.height[y0:y0+w, x0:x0+l]
        if region.size == 0:
            return 0
        return int(region.max(initial=0))

    def _raise_region(self, x0: int, y0: int, l: int, w: int, top: int, h: int) -> None:
        # region을 top+h까지 채움 (바닥은 top)
        self.height[y0:y0+w, x0:x0+l] = top + h

    def _H_tilde(self) -> int:
        return int(self.height.max(initial=0))

    def _gap(self) -> int:
        # g_i = L*W*H_tilde_i - sum_volumes
        return int(self.L * self.W * self._H_tilde() - self._sum_vol)

    # ---------- API ----------
    def reset(self, boxes: Optional[List[Box]] = None) -> Dict:
        self.height.fill(0)
        self.t = 0
        self._sum_vol = 0
        self._g_prev = 0
        self.placed_boxes = []   # 새로운 에피소드마다 초기화
        self.step_count = 0        # 성공 배치 카운트 초기화        
        self.invalid_count = 0     # 무효 시도 카운트 초기화
        
        if boxes is None:
            self.boxes = self._sample_boxes()
        else:
            self.boxes = [tuple(map(int, b)) for b in boxes]
        self.used = np.zeros(len(self.boxes), dtype=bool)
        obs = {
            "height": self.height.copy(),
            "remaining": (~self.used).sum(),
            "gap": self._gap(),
        }
        return obs

    def _sample_boxes(self) -> List[Box]:
        Lr = self.cfg.l_range
        Wr = self.cfg.w_range
        Hr = self.cfg.h_range
        boxes = []
        for _ in range(self.cfg.N):
            l = int(self.rng.integers(Lr[0], Lr[1] + 1))
            w = int(self.rng.integers(Wr[0], Wr[1] + 1))
            h = int(self.rng.integers(Hr[0], Hr[1] + 1))
            boxes.append((l, w, h))
        return boxes

    def step(self, action: Tuple[int, int, int, int]):
        """Place a box with action (x, y, box_idx, orient_idx).
        Returns: obs, reward, done, info
        """
        x, y, bidx, oidx = map(int, action)
        info: Dict[str, object] = {}

        # 1) 박스 선택 유효성
        if not (0 <= bidx < len(self.boxes)) or self.used[bidx]:
            self.invalid_count += 1
            obs = {"height": self.height.copy(), "remaining": (~self.used).sum(), "gap": self._gap()}
            info["reason"] = "invalid_selection"
            info["detail"] = f"bidx={bidx}, used={bool(self.used[bidx]) if 0 <= bidx < len(self.used) else 'n/a'}"
            done = False
            if self.invalid_count >= self.cfg.max_invalid_attempts:
                done = True
                info["terminated_by"] = "too_many_invalid"
            else:
                info["terminated_by"] = None
            info["invalid_count"] = self.invalid_count
            return obs, float(self.cfg.invalid_penalty), done, info

        # 2) 오리엔테이션 유효성
        l, w, h = self.boxes[bidx]
        orients = self._orientations(l, w, h)
        if not (0 <= oidx < len(orients)):
            self.invalid_count += 1
            obs = {"height": self.height.copy(), "remaining": (~self.used).sum(), "gap": self._gap()}
            info["reason"] = "invalid_orientation"
            info["detail"] = f"bidx={bidx}, oidx={oidx}, valid={len(orients)}"
            done = False
            if self.invalid_count >= self.cfg.max_invalid_attempts:
                done = True
                info["terminated_by"] = "too_many_invalid"
            else:
                info["terminated_by"] = None
            info["invalid_count"] = self.invalid_count
            return obs, float(self.cfg.invalid_penalty), done, info

        l2, w2, h2 = orients[oidx]

        # 3) 경계 체크 (벗어나면 즉시 종료)
        if not self._within_bounds(x, y, l2, w2):
            self.invalid_count += 1
            obs = {"height": self.height.copy(), "remaining": (~self.used).sum(), "gap": self._gap()}
            info["reason"] = "out_of_bounds"
            info["detail"] = f"xy=({x},{y}), size=({l2},{w2})"
            # 즉시 종료 대신 패널티만 주고 재시도 허용, 단 한도 초과 시 종료
            done = False
            if self.invalid_count >= self.cfg.max_invalid_attempts:
                done = True
                info["terminated_by"] = "too_many_invalid"
            else:
                info["terminated_by"] = None
            info["invalid_count"] = self.invalid_count
            return obs, float(self.cfg.invalid_penalty), done, info

        # 진행: 유효 배치만 성공 카운트 증가
        self.step_count += 1

        # 4) 배치: 해당 영역의 현재 최대 높이(top) 위에 올림
        top = self._max_height_in_region(x, y, l2, w2)
        self._raise_region(x, y, l2, w2, top, h2)
        self.placed_boxes.append((x, y, top, l2, w2, h2))

        # 5) 상태 갱신
        self.used[bidx] = True
        self.t += 1
        self._sum_vol += int(l2 * w2 * h2)

        g_now = self._gap()
        reward = float(self._g_prev - g_now)  # r_i = g_{i-1} - g_i
        self._g_prev = g_now

        # 6) 종료 판정 + reason
        done = False
        reason = "placed"  # 정상 배치가 이루어졌고 아직 종료가 아닌 경우의 기본 라벨
        if self.used.all():
            done = True
            reason = "no_space"  # 더 놓을 박스 없음(= 전부 배치 완료)

        # 성공 배치 한도
        if (self.max_steps is not None) and (self.step_count >= self.max_steps):
            done = True
            reason = "max_steps"

        info.update({
            "reason": reason,
            "H_tilde": self._H_tilde(),
            "gap": g_now,
            "sum_vol": self._sum_vol,
            "placed_box": (l2, w2, h2),
            "step_count": self.step_count,
            "invalid_count": self.invalid_count,
            "terminated_by": reason if done else None,
        })

        obs = {
            "height": self.height.copy(),
            "remaining": (~self.used).sum(),
            "gap": g_now,
        }
        return obs, reward, done, info
    
    def current_max_height(self):
        return int(self.height.max())

    # 선택: 정책 입력용 컨테이너 상태 7채널
    def container_state7(self) -> Optional[np.ndarray]:
        if compute_plane_features is None:
            raise RuntimeError("compute_plane_features is unavailable; install/enable utils.preprocess.")
        return compute_plane_features(self.height.astype(np.float32))

    def utilization_rate(self) -> float:
        Ht = self._H_tilde()
        denom = float(self.L * self.W * max(Ht, 1))
        if denom == 0:
            return 0.0
        return float(self._sum_vol) / denom
